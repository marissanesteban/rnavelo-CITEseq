---
title: "VeloViz Play"
author: "Marissa Esteban"
date: "2026-01-09"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
require(remotes)
remotes::install_github('JEFworks-Lab/veloviz')

# load packages
library(veloviz)
library(Matrix)
library(Seurat)
library(ggplot2)
```
```{r}
# rds input file path
rds_path <- "~/Desktop/marissasavethislater/UW_IFE.rds"

# read object
rds_file <- readRDS(rds_path)
```

```{r}
library(Matrix)

curr <- readMM("~/Documents/GitHub/rnavelo-CITEseq/velocity scripts/curr.mtx")
proj <- readMM("~/Documents/GitHub/rnavelo-CITEseq/velocity scripts/proj.mtx")

cells <- readLines("~/Documents/GitHub/rnavelo-CITEseq/velocity scripts/cells.txt")
genes <- readLines("~/Documents/GitHub/rnavelo-CITEseq/velocity scripts/genes.txt")

# MTX is CELLS x GENES
rownames(curr) <- cells
colnames(curr) <- genes
rownames(proj) <- cells
colnames(proj) <- genes

# Transpose to GENES x CELLS (VeloViz expects this)
curr <- t(curr)
proj <- t(proj)

# After transpose: rows=genes, cols=cells
rownames(curr) <- genes
colnames(curr) <- cells
rownames(proj) <- genes
colnames(proj) <- cells

# ---- Align Seurat metadata (obs) to base barcodes ----
obs <- rds_file@meta.data
# add base barcode column
obs$cell_base <- sub("-.*$", "", rownames(obs))

# build a named vector: names = base barcode, values = celltype
clusters_base <- obs$celltype
names(clusters_base) <- obs$cell_base

# Keep only cells present in curr/proj
keep <- obs$cell_base %in% colnames(curr)

# Build obs indexed by base barcode, ordered to match curr columns
obs_base <- obs[match(colnames(curr), obs$cell_base), , drop = FALSE]
rownames(obs_base) <- colnames(curr)

# ---- Sanity checks (these should now pass) ----
stopifnot(all(dim(curr) == dim(proj)))
stopifnot(identical(colnames(curr), colnames(proj)))
stopifnot(identical(rownames(curr), rownames(proj)))
stopifnot(identical(rownames(obs_base), colnames(curr)))

# quick peek
dim(curr)
head(colnames(curr))
head(rownames(curr))
head(rownames(obs_base))

```

```{r}
# For sparse dgCMatrix, actual stored values are in @x
sum(is.na(curr@x)); 
sum(is.nan(curr@x)); 
sum(is.infinite(curr@x))
sum(is.na(proj@x)); 
sum(is.nan(proj@x)); 
sum(is.infinite(proj@x))

# Also check negatives among stored values
sum(curr@x < 0, na.rm = TRUE)
sum(proj@x < 0, na.rm = TRUE)

```
```{r}
# Replace any non-finite values with 0 (just in case)
curr@x[!is.finite(curr@x)] <- 0
proj@x[!is.finite(proj@x)] <- 0

# Clip negatives to 0 (required for VeloViz assumptions)
curr@x[curr@x < 0] <- 0
proj@x[proj@x < 0] <- 0

# Confirm everything is clean
stopifnot(sum(!is.finite(curr@x)) == 0)
stopifnot(sum(!is.finite(proj@x)) == 0)
stopifnot(sum(curr@x < 0) == 0)
stopifnot(sum(proj@x < 0) == 0)

```


```{r}
veloviz_out <- buildVeloviz(
  curr = curr,
  proj = proj,
  normalize.depth = TRUE,
  use.ods.genes = TRUE,
  alpha = 0.05,
  pca = TRUE,
  nPCs = 20,
  center = TRUE,
  scale = TRUE,
  k = 5,
  similarity.threshold = 0.25,
  distance.weight = 1,
  distance.threshold = 0.5,
  weighted = TRUE,
  verbose = FALSE
)

emb.veloviz <- veloviz_out$fdg_coords  # cells x 2 (rows are cell IDs)
```

```{r}
set.seed(0)

# cells x genes (may be sparse)
X_cells_genes <- t(curr)

# compute PCA (base R prcomp can take a dense matrix; for big data this can be heavy)
pca <- prcomp(as.matrix(X_cells_genes), center = TRUE, scale. = FALSE)

pcs <- pca$x[, 1:10]   # cells x PCs
```

```{r}
# variance explained by each PC
var_explained <- pca$sdev^2
var_explained <- var_explained / sum(var_explained)

plot(
  var_explained[1:30],
  type = "b",
  pch = 19,
  xlab = "Principal Component",
  ylab = "Proportion of Variance Explained",
  main = "PCA Elbow Plot"
)

```


```{r}
# clusters aligned to the veloviz embedding
clusters <- obs[rownames(emb_use), "celltype"]
clusters <- as.factor(clusters)
names(clusters) <- rownames(emb_use)

```

```{r}
par(mfrow = c(2,2))

# PCA
emb.pca <- pcs[, 1:2]
plotEmbedding(emb.pca, groups = clusters_base[rownames(emb.pca)], main = "PCA")

# tSNE
set.seed(0)
emb.tsne <- Rtsne::Rtsne(pcs, perplexity = 30)$Y
rownames(emb.tsne) <- rownames(pcs)
plotEmbedding(emb.tsne, groups = clusters_base[rownames(emb.tsne)], main = "tSNE",
              xlab = "t-SNE X", ylab = "t-SNE Y")

# UMAP
set.seed(0)
emb.umap <- uwot::umap(pcs, min_dist = 0.5)
rownames(emb.umap) <- rownames(pcs)
plotEmbedding(emb.umap, groups = clusters_base[rownames(emb.umap)], main = "UMAP",
              xlab = "UMAP X", ylab = "UMAP Y")

# VeloViz
plotEmbedding(emb.veloviz, groups = clusters_base[rownames(emb.veloviz)], main = "VeloViz")

```



```{r}
# emb.veloviz rownames are base barcodes (e.g., "AAAC..."),
# but Seurat cell names include suffixes (e.g., "AAAC...-1_26").
# So: match on the base barcode, then rename rows to Seuratâ€™s full cell IDs.

seu_cells <- colnames(rds_file)
seu_base  <- sub("-.*$", "", seu_cells)          # strip "-1_26" (everything after first "-")
vv_base   <- rownames(emb.veloviz)               # already base barcodes

# keep Seurat cells that exist in the VeloViz embedding
keep <- seu_base %in% vv_base

# index VeloViz rows in the exact order of the kept Seurat cells
idx <- match(seu_base[keep], vv_base)

# subset + reorder embedding to match Seurat cell order
emb_use <- emb.veloviz[idx, , drop = FALSE]

# IMPORTANT: rename embedding rows to Seurat's full cell IDs
rownames(emb_use) <- seu_cells[keep]

# sanity checks
stopifnot(all(!is.na(idx)))
stopifnot(identical(rownames(emb_use), seu_cells[keep]))

# add as a Seurat reduction
rds_file[["veloviz"]] <- CreateDimReducObject(
  embeddings = as.matrix(emb_use),
  key = "VELOVIZ_",
)

# set the assay used by the reduction to RNA
rds_file[["veloviz"]]@assay.used <- "RNA"
```

```{r}
cells_vv <- Cells(rds_file[["veloviz"]])

DimPlot(
  rds_file,
  reduction = "veloviz",
  cells = cells_vv,
  group.by = "celltype",
  pt.size = 0.5
)

```

Also adding Umap generated by veloviz

```{r}
seu_cells <- colnames(rds_file)
seu_base  <- sub("-.*$", "", seu_cells)     # base barcode from Seurat cell IDs
umap_base <- rownames(emb.umap)             # base barcode from your computed UMAP

keep <- seu_base %in% umap_base
idx  <- match(seu_base[keep], umap_base)

emb_umap_use <- emb.umap[idx, , drop = FALSE]
rownames(emb_umap_use) <- seu_cells[keep]

# sanity
stopifnot(all(!is.na(idx)))
stopifnot(identical(rownames(emb_umap_use), seu_cells[keep]))

```

```{r}
rds_file[["vv_umap"]] <- Seurat::CreateDimReducObject(
  embeddings = emb_umap_use,
  key = "VVUMAP_",
  assay = "RNA"
)
```


```{r}
cells_umap <- Cells(rds_file[["vv_umap"]])

DimPlot(rds_file, reduction = "vv_umap", cells = cells_umap, group.by = "celltype")

```
```{r}
Reductions(rds_file)
```

```{r}
p1 <- DimPlot(
  rds_file,
  reduction = "umap.pca20",
  group.by = "celltype",
  pt.size = 0.4
) + ggtitle("PCA (20 PCs)")

p2 <- DimPlot(
  rds_file,
  reduction = "umap.harmony",
  group.by = "celltype",
  pt.size = 0.4
) + ggtitle("UMAP (Harmony)")

p3 <- DimPlot(
  rds_file,
  reduction = "umap.rpca",
  group.by = "celltype",
  pt.size = 0.4
) + ggtitle("UMAP (RPCA)")

p4 <- DimPlot(
  rds_file,
  reduction = "vv_umap",
  group.by = "celltype",
  pt.size = 0.4,
  cells = Cells(rds_file[["vv_umap"]])   # IMPORTANT
) + ggtitle("UMAP (Ms / velocity space)")

p1 | p2 | p3 | p4
```

```{r}
saveRDS(rds_file, file = "~/Desktop/marissasavethislater/UW_IFE.rds")

# saving the velocity-only rds object (subset to smaller cell numebr)
cells_vv_full <- Cells(rds_file[["veloviz"]])
rds_vv <- subset(rds_file, cells = cells_vv_full)
saveRDS(rds_vv, "~/Desktop/marissasavethislater/UW_IFE_veloViz.rds")

```
